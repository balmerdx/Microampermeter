Микроамперметр с диодом.
Заодно является источником питания 



ADP3334 - LDO adjustable https://aliexpress.ru/item/4000185527155.html
TL072 как усилитель перед LDO
AD8221 как дифф усилитель
STM32H750

https://aliexpress.ru/item/33007959640.html  - 10Mohm resistor


Статейка о том, что с 6.8 Ом резистором можно в широком диапазоне измерять.
https://www.ti.com/lit/ug/tidu033/tidu033.pdf?ts=1596393210408&ref_url=https%253A%252F%252Fwww.google.com%252F

Это будет именно блок питания с измерением тока.
Пускай всегда от 220 вольт питается.
Возможность подключать к компьютеру для снятия графиков.
Возможность менять напряжение от 1.2 до 3.3 вольта .

Отображение как тока, так и сопротивления.
Самое главное - график изменения со временем.
Протестируем на конденсаторе, достаточно ли линейная шкала.

Предположим у нас 100 КОм и 12 бит честных есть. 


https://aliexpress.ru/item/4000919520888.html - энкодер, положение которого известно

Сделать совсем простой микро-наноампрметр.
Он должен.

TPS79301 - неплохой LDO
ADP3334 - тоже хороший

ADS127L01 20$ 512 ksps - ему требуется дифференциальный сигнал, отпадает (зато отлично подходит для RLC измерителя!!!)
ads1251 18$ (mouser) 7.7$ (lcsc) - лучше тут две купить, чем в mouser одну

ads1251 - ему требуется 8 МГц clock (это легко устроить)
AD8418 как неплохой zero drift current amplifier
INA213 тоже нормальный, с низким потреблением и уровнем шума
INA213 - 50 раз усиление. 2 вольта будет при 40 милливольт входном сигнале.

INA240A1PWR - 20 раз усиление. Похоже входное споротивление у неё 3 KOm (TSSOP-8_3x4.4x065P)

AD823 jfet amplifier 


Пускай у нас резистор 1 КОм, какой будет 1 uA сигнал?
AD8418 (INA240A1) усиливает в 20 раз, это будет 20 мВ.
У нас 19 бит на 3 вольта.
Получается аж 3000 отсчетов на микровольт! Правда максимальный ток измерения будет всего 150 uA. 10 ом - 15 ма (маловато будет!), надо будет ещё и 1 ом прикрутить видимо.

TMP112 около диода? Или ну его нафиг?

PA8 для выхода 8 МГц сигнала на ADC
Нужен ещё step up до +5V напряжения.
TPS61240DRVR - отлично подходит к нашей задаче

FT230XQ - подойдёт чтобы передавать наши данные

MAX12931 - как защита usb порта. - нет в LCSC
ISO7221BDR - нам вроде подходит

SSM3K345R,LF - подойдёт такой транзистор для переключения 1 Ом, остальные можно SI2302 переключать, впрочем можно и IRLML2502 использовать


- HLK-1D0505 изолированный преобразователь 200 мА
	слишком слабенький
 IB0505S-2W 400мА
 F0505S-2W 400мА
 Понятно, почему у них проблемма со стабильностью. На выходе там всеголишь пара диодов и все. Никакого feedback

 Как вариант взять ткмблер MTS-202 или MTS-203 чтобы подключаться к питанию

- резистор для TPS79301
- нарисовать USB через FT230XQ и ISO7221BDR

- резистор 1 Ом дольжен быть побольше
- проверить расположение UART разъёма по оси Y
- проверить расположение левой части коннекторов дисплея по оси X 


Что купить
FT230XQ     *
ISO7221BDR  *

INA240A1PW  *
ADS1251     *
TPS79301-EP *

Резисторы 0.1%
	1.2 Ом 0805 0.5% 25 ppm *
	10 Ом 0603 0.1%  *

	выводные 1 МОм 3 МОм 10 МОм *



Щупы входные
banana plug  - как вариант для щупов 
4 мм возможно неплохой вариант
https://aliexpress.ru/item/32323780790.html



- какие резисторы мы можем использовать, для 8 pF пина LCD экрана
	причина - МК питается от 3.3 вольта, а LCD от 3.0 вольта
	надо бы резисторы побольше, что-бы ток лишний не тек

	У нас частота 12 МГц, надо, чтобы зарядился до 90% за 20% времени?
	Попробуем резисторы 300 Ом R7-R12

- почти нет 
	22 pF
	22 Kom


- USB определяется
	/dev/ttyACM0

- глянуть, что 8 МГц сигнал есть --ok
- LCD дисплей для логов --ok
- написать софтварный драйвер для ADS1251
	- начали  писать, получили первые цифры
	- использовать hardware SPI --не получилось. SPI4 не поддерживает 24 бита

	- наш софтварный SPI работает со скоростью 7 микросекунд на 24 бита, т.е. 3 МГц
		ну и пускай пока так работает

SoftwareSPI24:
	push	{r4, r5}
	movs	r1, #24
	movs	r0, #0
	ldr	r2, .L15
	mov	r5, #4096
	mov	r4, #268435456
.L12:
	lsls	r0, r0, #1
	str	r5, [r2, #24]
	mov r0, r0
	mov r0, r0
	mov r0, r0
	ldr	r3, [r2, #16]
	subs	r1, r1, #1
	str	r4, [r2, #24]
	ubfx	r3, r3, #14, #1
	orr	r0, r0, r3
	bne	.L12

	pop	{r4, r5}
	bx	lr
	
.L15:
	.word	1476530176


	- напряжение на выходе
	- расчет сопротивления резистора
	


- думаем над тем, чем заменить INA240

	TLE2072IDR - J-FET 3$ 
		Input offset voltage 0.3 mV
		Input offset current 5 pA
		Ensured Maximum Noise Floor 17 nV/√Hz

	AD8139 
		Input Voltage Noise 2.25 nV/√Hz
		Input Offset Voltage ±150 μV
		Input Offset Current 0.12 μA

	AD8512ARZ  - вполне подходит
	AD8510 - один усилитель 
		Offset Voltage (A Grade) 0.1  mV 
		Input Offset Current  5 pA 
		Low noise: 8 nV/√Hz
		её вход желательно защитить чем либо.

	LT1055 - тоже хорош, но его нет в LCSC
		Input Offset Voltage  100  µV 

	Ad8628, Ad8629 отличные низкошумящие Zero-Drift, есть в LCSC


	balmer:LTC1550LCS8
	Package_SO:TSSOP-8_3x3mm_P0.65mm



Сумматор --fail, т.к. инвертирующий сумматор получился
	Vref = 2
	Vin
	Rin = RVref = Rf(eedback)

	Vin/Rin+Vref/RVref = Vout/Rf
	Vin+Vref=Vout

	

Выбираем ещй раз ADC 
	ads1252 ads1251 - плохи тем, что там Data Ready на data out. Непонятьно как без FPGA подключать.
	ADS1252 лучше, чем ads1251 при той-же стоимости.
	Там кстати есть Level Shift Circuit for Bipolar Input Ranges

	ADS1255 вроде избавлен от такого недостатка, но из-за PGA может drift иметь...
		SG-8101CA 7.680000MHz TCHPA - есть для него кристал в lcsc

	Поискать ADC от 3.3V работающее

	FPC-8P 0.5mm - нам бы такой вариант пригодился для межплатных соединений
		https://aliexpress.ru/item/10000013182312.html
		https://aliexpress.ru/item/10000348360254.html

	Altera 10M02DCV36C8G - очень бы пригодилось
		1.2 VCC 
		2.5 VCC_ADC
		3.3 VCC_IO (может быть от 1V до 3.3V)
	У нас есть 14 пинов IO
	Прикинем, что пожно наконфигурировать.
		CSLK/DOUT - по два пина на ADC
		SPI - CS/DI/DO/SCK - четыре пина, более чем достаточно
		ADS127L01 - можно будет буферизировать

	2.5V регуляторы небольшого размера
		HT7125-3 - 30 мА
		ME6209A25M3G  - 40 мА SOT23-3, дешевый очень
		ME6206A25XG - 100 мА SOT23-3, ещё дешевле
	1.2V регуляторы небольшого размера
		ME6211C12M5G-N - SOT23-3
		XC6504A1219R-G - прикольный USPQ-4B04 корпус


Voltage Reference 4 V
	https://lcsc.com/product-detail/Voltage-References_Texas-Instruments_LM4140CCM-4-1-NOPB_Texas-Instruments-Texas-Instruments-LM4140CCM-4-1-NOPB_C205911.html


	+5V помощнее нежен источник для двух ADC и нескольких operational amplifier

	HX4002 - вполне подходит. На 1 MHz сильно шуметь не будет


	Да, получится достаточно компактный Dual ADC + FPGA который можно использовать для всяуого

	AD8629 в качестве предусилителя.

	Level shifter TXS0108EPWR для согласования с 5-ти вольтовой системой.


	Нам нужно рапссчитать Level shifter, чтобы работал от -1V до +4V
	Если Level shifter питать от напряжения GND=0V, VCC=5V, то сможем использовать AD8629
	Предусилитель надо питать от GND=-2V VCC=+3.3 V


https://www.thingiverse.com/thing:4604732/files - among us

Раз с Max 10 не выгорело, то попробуем используя Hardware SPI передавать по 24 бита (а потом гасить его).
	Для проверки напишем код на Cyclone 10, который будет эмулировать поведение ADS1251/ADS1252

	Можно SRAM в QSPI корпусе использовать 
	LY68L6400 - 8 МБ SRAM памяти

Поискать всётаки другое ADC, чтобы сигнал data ready был отдельно от SPI
ADS1271 неплох, отдельное DVDD, отдельное Data ready
Кажется FSync - это I2S вариант

Yangxing Tech OT252027MJBA4SL - 10ppm вполне неплох 27 МГц 1.8-3.3V
SI2302 - больше 10 МОм, что для нас более чем хорошо

600Z
	ESR=0.05 Om 30 Hz
	ESR=0.3 Om 500 КHz
	L = 2 uH

100 uH есть две
	более мелкие ESR = 1.5 Ом
	крупные ESR = 0.9 Ом

- Сделать ADC часть более-меннее качественную.
	Желательно все резисторы 0.1% точности
	TPS60241 вытягивает только один ADC на HighSpeed mode./

- сделать STM32 часть, которая будет соединяться с ADC частью боковыми разъёмами
	USB разъём сверху
	колесико для управления тоже сверху.

	I2S это оказывается SPI такой нам не подходит, нужно именно SAI
	QSPI пускай будет и ведёт к FLASH/RAM ?

	~/radio/stm32/tmp/TestH743_USB - настроили SAI на приём данных, теоретически должно прокатить.

	CLK
	SCLK
	FSYNC
	DOUT
	~SYNC

	https://aliexpress.ru/item/4000134726887.html - боковые 1.25 мм разъёмы для SWD
	https://aliexpress.ru/item/4000127273548.html

	https://aliexpress.ru/item/1005001493344800.html
	https://aliexpress.ru/item/1005001493370547.html

	разъёмы заказали
	платы заказали

- список покупаемых микросхем/деталей
	AD8629ARZ-REEL7   0 шт
	AD8628ARTZ-REEL7 12 шт
	ADS1271 - 2 шт (или таки 4 шт?)
	LM4140CCMX-2.5/NOPB - 1 шт
	LY68L6400 - 8 МБ SRAM памяти
	1.5k 0.1% 0603 - нет
	27k 0.1% - есть

	Пусть будет 18к и 1k


- вариант clock на 400 МГц
	- CPU 400 MHz
	- after HRE 200 МГц
	- USART 2,3 = 100 МГц
	- SPI 4,5 = 100 МГц
	- ADC 96 МГц
	- USB 48 МГц

	divm1 8 -> 2
	divq1 2 -> 8
	hpre 1 -> 2 (частота до 200 МГц вырастет)

	При частоте ядра 100 МГц потребление 96 мА (вместе с дисплеем)
	При частоте ядра 400 МГц потребление 125 мА (вместе с дисплеем)
	Пускай будет всегда 400 МГц


- прикрутить encoder --ok
	
lcsc с  AD8628 и ADS1271
https://www.pochta.ru/tracking#RL363908055EE
Детальки для Allwinner V3S
https://www.pochta.ru/tracking#RL363913373EE

Заказ №64747 на сайте nadomfoto.ru

https://www.youtube.com/watch?v=U9t2D6QLnVM
https://pythonprogramming.net/displaying-images-pygame/

- что нам требуется от микроамперметра
	- измерение тока (и калибровка нуля)
	- измерение напряжения (точность там никакущая и калибровкой делу не поможешь)
	- переключение вариантов измерения
		ток (средний/минимальный/максимальный за последние пол секунды)
		напряжение + ток
		сопротивление

- сделать драйвер QSPI RAM --ok
	Оказывается у Quad SPI есть bank1/bank2 и это разные вещи.
	Неверно развели ~QSPI_CS на bank1, хотя всё остальное на bank2

	Чтож, PC11 нужно использовать.

	QSPI скорость 1427 us на 10000 байтов 7 МБ/сек  (это при чтении HAL_QSPI_Receive софтварно)
	Используя HAL_QSPI_Receive_DMA получаем 352 us, т.е. 28 МБ/сек

	- проверить всю память --ok

- ADS1271 запаять

- FSMC и 8080 дисплей (можно ускорить в разы используя FSMC)!
	https://www.compel.ru/lib/90626
	PC0 - FMC_SDNWE
	PC2 - FMC_SDNE0
	PC4 - FMC_SDNE0
	PC7 - FMC_NE1  
	PC8 - FMC_NE2/FMC_NCE
	PD4 - FMC_NOE  ****** 85
	PD5 - FMC_NWE  ****** 86
	PD7 - FMC_NE1  ****** 88
	PD11 - FMC_A16 ****** 58
	PD12 - FMC_A17
	PD13 - FMC_A18

	PD14 - FMC_D0/FMC_DA0 61
	PD15 - FMC_D1/FMC_DA1 62
	PD0  - FMC_D2/FMC_DA2 81
	PD1  - FMC_D3/FMC_DA3 82
	PE7  - FMC_D4/FMC_DA4 37
	PE8  - FMC_D5/FMC_DA5 38
	PE9  - FMC_D6/FMC_DA6 39
	PE10 - FMC_D7/FMC_DA7 40
	PE11 - FMC_D8/FMC_DA8 41
	PE12 - FMC_D9/FMC_DA9 42
	PE13 - FMC_D10/FMC_DA10 43
	PE14 - FMC_D11/FMC_DA11 44
	PE15 - FMC_D12/FMC_DA12 45
	PD8  - FMC_D13/FMC_DA13 55
	PD9  - FMC_D14/FMC_DA14 56
	PD10 - FMC_D15/FMC_DA15 57

- ADS1271 получить данные используя SAI

	/home/balmer/radio/stm32/new_lib/h7/STM32Cube_FW_H7_V1.5.0/Projects/STM32H743I-EVAL/Examples/SAI
	https://community.st.com/s/question/0D53W000003L5VG/does-dma-miss-data-while-it-is-used-by-sai-interface

	- HAL_SAI_Receive_DMA почемуто не работает --ok, надо было в правильный блок памяти буфер запихать

	- MODE 
		MODE = 0 High Speed
		к сожалению ошиблись, поэтому High Resolution у нас пока не будет (т.к. надо float по отдельности делать)

	- ~SYNC/~PDWN = 1 	

	- DMA не работает --ok
		DMA1_Stream0_IRQHandler вызывается, если HAL_SAI_Receive_DMA вызывать
		HAL_SAI_RxHalfCpltCallback - тоже вызывается
		SCB_InvalidateDCache_by_Addr помогло


- слишком большие уровни сигнала
	- U6, U2 по хорошему надо питать от 0 и +5 V (а сейчас питание от 0 до 3.3V)

	Для начала сделаем так - на плате с ADC
	Перепаяем LT4140 на 2.0 вольта 
	Уменьшим коэффициент усиления входной до 10 (перепаяв резисторы на 3k )
	140*10 = 1.4 

	Уменьшим напряжение перепаяв резистор на R4 750 Ом (на синей плате)

- быстрое переключение пределов измерения --ok
	- собрать источник быстроменяющегося сопротивления (резисторы+управляющие транзисторы) --ok

- думаем про GUI
	- вынести GUI и тестовый код из main
	- калибровка offset/scale
	- основной диалог, варианты отображаемой информации
		- ток (+напряжение мелким шрифром)
		- мощность (+ток/напряжение)
		- сопротивление

	- диалог с гистограммами потребления
	

- попробовать for fun перейти на clang
	https://interrupt.memfault.com/blog/arm-cortexm-with-llvm-clang
	даже заработало, но смысла в этом не вижу



- arm-none-eabi-objdump --disassemble output/program_release.elf

- как делаем временную коррекцию
	Vcurrent - измеренное значение 
	k - коэффициент корреции
	current = Vcurrent/Rshunt
	resistance = (Vout-Vcurrent)/current;
	resistance = (Vout-Vcurrent)/(Vcurrent/Rshunt)

	resistance/Rshunt = Vout/Vcurrent*k-1

	k = (resistance/Rshunt+1)*Vcurrent/Vout
	Vcurrent = 11.649
	Vout = 1222.3


- по хорошему на входе должен быть автоматический вариант "закоротить вход и посмотреть offset"


Keysight N6705C
https://www.keysight.com/ru/pd-2747858-pn-N6705C/dc-power-analyzer-modular-600-w-4-slots?nid=-35714.1195294&cc=RU&lc=rus

- переключать быстро диапазон
	- уменьшить DMA так, чтобы по 16-ть сэмплов за раз было --ok
	- определить, ADC min/max когда переключать --ok
	- отпаять конденсаторы 22 nF --ok
	- почемуто странно график перескакивает, подозреваю, что не по порядку данные идут
		подключить резистор 10 КОм в питание и конденсатор 1 µF параллкельно и заряжать/разряжать его

- void HAL_MDMA_IRQHandler(MDMA_HandleTypeDef *hmdma) - заменить укороченной версией без обработки ошибок --ok

- убедиться, что милисекундный таймер имеет худший приоритет, чем DMA --ok
	да, по умолчанию у него худший приоритет, так что DMA не перебъёт


- сделать промежуточный массив, не очень большой, на 4 милисекунды --пока не видно, зачем это необходимо, можно и в том-же прерывании по быстрому перекинуть данные
	разбить этот массив на 4 части и каждую из частей маркировать как full при записи, и как empty при чтении
	так как бы будем и то и другое писать
	Это будет наш "непереполняемый FIFO"
	На этом этапе уже желательно правильно упаковать, чтобы R было с соответствующим сдвигом

- сделать FIFO буфер который будет храниться в QSPI SRAM

- в big_buf пускай попадают уже очищенные данные
	SAMPLES_R_ERROR должно использоваться в ADS1271_ReceiveData --ok
		r_invalid должно исчезнуть

- вынести adc0_result, adc1_result, samples_count, adc_store_request и т.д. в отдельную функцию и файл. --ok

- сделать окошко микроамперметра/сопротивления более красивым
	мелким шрифтом
	- текущий используемый резистор --ok
	- напряжение --ok
	- средний ток и среднее сопротивление --ok
	- ток минимальный и максимальный --ok

- очень большой фонт --ok
	0123456789.-
	nµmAKMO - не нужно, большие слишком получаются

- Фильтровать надо уже ток, для того, чтобы при переключении диапазонов выбросов не было. --ok

- начать делать меню
	- переключение максимальной частоты --ok
	- переключение current stats/resistance --ok

- режем частоты IIR фильтром --ok
	max = 50 КГц (без фильтра)
	min = 40 Гц

- калибровка
	оказывается нам негде хранить значения калибровки, в STM32H750 весь flash стирается целиком, все 128 КБ
	будем хранить в недокументированной части, так как там flash 1 МБ есть
	Проверить, что страница 

	offset zero надо сделать обязательно
	остальное просто измерением напряжения попытаемся синхронизировать
	

- сделать окошко с гистограмками
	По оси X - откладываем ток (логаричмическая шкала)
	По оси Y откладываем мощность (ток помноженный на время)

	Если гистограмму сделать достаточно подробной, то можно, попиксельно


	514 µs  на 1000 sinf, при частоте 400 МГц получается 200 тактов на синус


- проверить работу с qspi flash
	- проверить чтение/записть
	- erase 4k
	- erase 64k
	- erase all
	- чтение/записть короткого блока, не выровненное в начале и в конце
	- чтение/записть не выровненное в начале
	- чтение/записть не выровненное в конце

	- не забыть вернуть нормлаьный hqspi.Init.ClockPrescaler = 32;

	Erase 4k - 

- напряжение питания
	если меньше 3.2 V пишем low bat - большими и красными буквами!
